accumulate coc-ljf.
accumulate certificates/dd.
% accumulate certificates/latex.
accumulate latex_tools.
accumulate certificates/pairing.
accumulate certificates/interactive.

%% Helper predicates
type loop prop -> prop.
loop G :- G, fail.
loop _G.
type build_clause (pair term term) -> prop -> prop.
build_clause (pr A B) (store dd_index A B).

%% Some local pretty-printing code
pred pretty_psort i:ps, o:string.
pretty_psort (p X) String :- sort_name X Name, String = Name ^ "^+".
pretty_psort (n X) String :- sort_name X Name, String = Name ^ "^-".
pred pretty_context i:list (pair term term), o:string.
pretty_context [] "".
pretty_context [T|Rest] OutStr :- term_to_latex {fst T} TString1, term_to_latex {snd T} TString2, pretty_context Rest RestStr, OutStr = TString1 ^ ":" ^ TString2 ^ "," ^ RestStr.
pred pretty_axrels i:list prop, o:string.
pretty_axrels [] "".
pretty_axrels [axiom A B | Rest] OutString :-
  pretty_psort A AName, pretty_psort B BName, pretty_axrels Rest PRest, OutString = "$axiom (" ^ AName ^ "," ^ BName ^ ")$ " ^ PRest.
pretty_axrels [rel A B C | Rest] OutString :-
  pretty_psort A AName, pretty_psort B BName, pretty_psort C CName, pretty_axrels Rest PRest, OutString = "$rel (" ^ AName ^ "," ^ BName ^ "," ^ CName ^ ")$ " ^ PRest.

%% The example-printing loop. Takes axioms, decide-depth bound, context, goal, prints
%% all possible solutions as a LaTeX itemize list

type exampleAll list prop -> list prop -> int -> list (pair term term) -> term -> prop.
:if "DEBUG:exall" exampleAll AxRels _PP_Hints Int Ctx Goal :-
!, print "Attempting" Goal "\n", std.map Ctx build_clause StoreCtx,
  StoreCtx => AxRels => loop (sigma Term\ asyncr (dd Int) Term (unk Goal), print "Found" Term "\n").

exampleAll AxRels PP_Hints Int Ctx Goal :-
  std.map Ctx build_clause StoreCtx,
  StoreCtx => AxRels => PP_Hints =>
  (
  pretty_axrels AxRels AxRelStrings, pretty_context Ctx CtxStr, term_to_latex Goal GoalStr,
  Intro is "In the system given by " ^ AxRelStrings ^ "print all terms of type $" ^ GoalStr ^ "$ with context ${" ^ CtxStr ^ "}$ and decide-depth " ^ (int_to_string Int),
  print Intro,
  print "\\begin{itemize}",
  loop
   (
     sigma Term\
       asyncr (dd Int) Term (unk Goal),
       term_to_latex Term String,
       OutStr is String,
       print "\\item $" OutStr "$"
   )),
  print "\\end{itemize}".

type exampleCheck list prop -> list prop -> int -> list (pair term term) -> term -> term -> prop.
exampleCheck AxRels PP_Hints Int Ctx Term Goal :-
  std.map Ctx build_clause StoreCtx,
  StoreCtx => AxRels => PP_Hints =>
  (
  pretty_axrels AxRels AxRelStrings, pretty_context Ctx CtxStr, term_to_latex Goal GoalStr, term_to_latex Term TermStr,
  Intro is "In the system given by " ^ AxRelStrings ^ " in the context ${" ^ CtxStr ^ "}$ check whether $" ^ TermStr ^ "$ has type $" ^ GoalStr ^ "$ with decide-depth " ^ (int_to_string Int),
  print Intro,
  asyncr (dd Int) Term (unk Goal),
  print "Yes!").

:if "DEBUG:main" main :- !,
pi prop\ pi ty\
  axiom (n prop) (n ty) =>
  rel (n prop) (n prop) (n prop) =>
  rel (n ty) (n prop) (n prop) =>
  sigma T\
      asyncr (dd 4) % T (unk (prod o (_\o) (kappa (sort (n prop)) (x\ prod x (_\x) (kappa (sort (n prop)) (y\ posbox y)))))),
      (prod (sort (n prop)) (o\ negbox (prod (sort (n prop)) (p\ negbox (prod (negbox (app o #)) (_\ negbox (app p #)) #) ) #)) #)
      (unk (sort (n prop))),
      print "a" T.


:if "DEBUG:exall" main :- loop (example X_).
main :- 
print "\\documentclass{scrartcl}
\\usepackage{proofsystem_macros}
\\title{Some examples terms}
\\begin{document}",
loop (example X_),
print "\\end{document}".

%% The examples are below
type example string -> prop.
example "NpropNtyNa_Nprop" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (n prop) (n ty), rel (n prop) (n prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (n prop))] (sort (n prop)).
example "NpropPtyNa_Nprop" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (n prop) (p ty), rel (n prop) (n prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (n prop))] (sort (n prop)).
example "PpropPtyPa_Nprop" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (p prop) (p ty), axiom (n prop) (p ty), rel (p prop) (p prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (p prop))] (sort (n prop)).
example "PpropPtyPa_Pprop" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (p prop) (p ty), axiom (n prop) (p ty), rel (p prop) (p prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (p prop))] (sort (p prop)).
example "PpropNtyPa_Nprop" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (p prop) (n ty), axiom (n prop) (p ty), rel (p prop) (p prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (p prop))] (sort (n prop)).
example "IdentityAllNeg" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (n prop) (n ty), rel (n prop) (n prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (n prop))] (prod (negbox (app a #)) (x\ negbox (app a #)) #).
example "IdentityAllPos" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (p prop) (n ty), axiom (n prop) (n ty), rel (p prop) (p prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (p prop))] (prod (negbox (app a #)) (x\ negbox (app a #)) #).
example "NegNaturalsNegType" :-
pi prop\ pi ty\ pi o\ exampleAll [axiom (n prop) (n ty), rel (n prop) (n prop) (n prop)] [term_to_latex o "o", sort_name prop "Prop", sort_name ty "Type"]
      5 [pr o (sort (n prop))] (prod (negbox (app o #)) (x\ negbox (prod (negbox (prod (negbox (app o #)) (x\ negbox (app o #)) #)) (x\ negbox (app o #)) #)) #).
example "PosNaturalsNegType" :-
pi prop\ pi ty\ pi o\ exampleAll [axiom (n prop) (n ty), axiom (p prop) (n ty), rel (p prop) (n prop) (n prop), rel (n prop) (p prop) (n prop), rel (p prop) (p prop) (n prop), rel (n prop) (n prop) (n prop)] [term_to_latex o "o", sort_name prop "Prop", sort_name ty "Type"]
      4 [pr o (sort (p prop))] (prod (negbox (app o #)) (x\ negbox (prod (negbox (prod (negbox (app o #)) (x\ negbox (app o #)) #)) (x\ negbox (app o #)) #)) #).
example "NegNaturalsPosType" :-
pi prop\ pi ty\ pi o\ exampleAll [axiom (n prop) (p ty), rel (n prop) (n prop) (n prop)] [term_to_latex o "o", sort_name prop "Prop", sort_name ty "Type"]
      7 [pr o (sort (n prop))]
      (prod o (_\o) (kappa (sort (n prop)) (x\ prod x (_\x) (kappa (sort (n prop)) (y\ posbox y))))).
example "NegativeLFTypes" :-
%   print "Ninth example: given an empty context,
%   build all possible negative LF propositions with decide-depth 3.\n",
pi prop\ pi ty\ exampleAll [axiom (n prop) (n ty), rel (n prop) (n prop) (n prop), rel (n ty) (n prop) (n prop)] [sort_name prop "Prop", sort_name ty "Type"]
      3 [] (sort (n prop)).
example "LFSimpleImp" :-
pi prop\ pi ty\ exampleCheck [axiom (n prop) (n ty), rel (n prop) (n prop) (n prop), rel (n ty) (n prop) (n prop)] [sort_name prop "Prop", sort_name ty "Type"]
      4 [] (prod (sort (n prop)) (o\ negbox (prod (sort (n prop)) (p\ negbox (prod (negbox (app o #)) (_\ negbox (app p #)) #) ) #)) #)
      (sort (n prop)).
example "LFNatType" :-
pi prop\ pi ty\ exampleCheck [axiom (n prop) (n ty), rel (n prop) (n prop) (n prop), rel (n ty) (n prop) (n prop)] [sort_name prop "Prop", sort_name ty "Type"]
      4 [] (prod (sort (n prop)) (o\ negbox (prod (negbox (prod (negbox (app o #)) (_\ negbox (app o #)) #)) (_\ (negbox (prod (negbox (app o #)) (_\ negbox (app (sort (n prop)) #)) #)) ) #)) #)
      (sort (n prop)).

% example "LFNaturals" :-
%   print "Tenth example: Church naturals in LF; negative atom, traditional type syntax",
%   pi prop\ pi ty\       % Sort Prop and Sort Type
%     axiom prop ty =>    % Prop is a Type
%     rel prop prop prop =>   % Non-dependent product between prop
%     rel ty prop prop =>   %  Props depending on terms
%     sort_name prop "Prop" => sort_name ty "Type" => 
%     exampleLoop 5 [] (prod (sort (n prop)) (a\ (prod (app a #) (x\ prod (prod (app a #) (x\ app a #)) (x\ app a #))))).
% example "LFNaturalsSharedType" :-
%   print "Tenth example: Church naturals in LF; negative atom, shared type syntax",
%   pi prop\ pi ty\       % Sort Prop and Sort Type
%     axiom prop ty =>    % Prop is a Type
%     rel prop prop prop =>   % Non-dependent product between prop
%     rel ty prop prop =>   %  Props depending on terms
%     sort_name prop "Prop" => sort_name ty "Type" => sigma Ty\
%     exampleLoop 5 [] (prod (sort (n prop)) (a\ app (prod (app a #) (x\ app a #)) (kappa Ty (i\ (prod (app a #) (x\ prod i (y\ app a #) )))))).

% % example "NegativeSystemF" :-
% %   print "Sixth example: given a context containing only a negative prop $a$,
% %   build all possible negative System F propositions with decide-depth 2.\n",
% %   pi prop\ pi ty\       % Sort Prop and Sort Type
% %     axiom prop ty =>    % Prop is a Type
% %     rel prop prop prop =>   % Non-dependent product between prop
% %     rel ty prop prop =>   %  Props depending on terms
% %     rel prop ty ty =>   %  Props depending on terms
% %     pi a\ term_to_latex a "a" =>
% %       exampleLoop 2 [pr a (sort (p prop))] (sort (n prop)).

% % example "IdentitySystemF" :-
% %   print "Seventh example: given a context containing only a negative prop $a$,
% %   build all possible System F terms of type $\\ptsapp{a}{\\ptsnil}$ with decide-depth 5.\n",
% %   pi prop\ pi ty\       % Sort Prop and Sort Type
% %     axiom prop ty =>    % Prop is a Type
% %     rel prop prop prop =>   % Non-dependent product between prop
% %     rel ty prop prop =>   %  Props depending on terms
% %     pi a\ term_to_latex a "a" =>
% %       exampleLoop 5 [pr a (sort (n prop))] (prod (app a #) (x\ app a #)). %% Given "a" positive, build all negative propositions 
