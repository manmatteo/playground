accumulate coc-ljf.
accumulate certificates/dd.
% accumulate certificates/latex.
accumulate latex_tools.
accumulate certificates/pairing.

type pr s. % sort prop
type ty s. % sort type
% All sorts are negative. Old method!!
% sortn pn.
% sortp pp.
% sortn t.
% Prop is a type, and the only product is ->
axiom pr ty.
rel pr pr pr.

type loop prop -> prop.
loop G :- G, fail.
loop _G.

main :-
  pi a\
  store dd_index a (sort (p pr)) => 
  term_to_latex a "a" =>
  (
    sigma Term\
  % asyncr (dd 1) (app [a]) (str (sort p)),
  % print "Pass 1",
  % % Identity
  % asyncr (dd 3) (fun _N (app [a]) (x\ negbox (app [x]))) (unk (prod _N (app [a]) (x\ app [a]))),
  % print "Pass 2",
   loop (
  % % Naturals
  % asyncr (dd 6) Term (unk (prod _N (app [a]) (x\ (prod _ (prod _ (app [a]) (x\ app [a])) (x\ app [a]))))),
  % % Shared naturals
  % asyncr (pairing (dd 4) (latex (async [pr "a" (ptssort "Prop")] [] T (ptsprod "x" "a" (ptsprod "y" (ptsprod "z" "a" "a") "a")) hole) Str)) Term
  %        %(fun _ (app [a]) c1\ fun _ (prod _ (app [a]) y\ app [a]) c2\ negbox (app [c2, c1| kappa _ (app [a]) (x\ posbox x)]))
  %        (unk (prod _ (app [a]) (x\ (prod _ (prod _ (app [a]) (x\ app [a])) (x\ app [a]))))),
  asyncr (dd 3) Term
         %(fun _ (app [a]) c1\ fun _ (prod _ (app [a]) y\ app [a]) c2\ negbox (app [c2, c1| kappa _ (app [a]) (x\ posbox x)]))
         (unk (prod (app a #) (x\ (prod (prod (app a #) (x\ app a #)) (x\ app a #))))),
  % print "Built " Term "\n"
  term_to_latex Term TTex,
  print "Built $" TTex "$\n"
   )
  ).
