accumulate coc-ljf.
accumulate certificates/dd.
% accumulate certificates/latex.
accumulate latex_tools.
accumulate certificates/pairing.

%% Helper predicates
type loop prop -> prop.
loop G :- G, fail.
loop _G.
type build_clause (pair term term) -> prop -> prop.
build_clause (pr A B) (store dd_index A B).

%% Some local pretty-printing code
pred pretty_psort i:ps, o:string.
pretty_psort (p X) String :- sort_name X Name, String = Name ^ "^+".
pretty_psort (n X) String :- sort_name X Name, String = Name ^ "^-".
pred pretty_context i:list (pair term term), o:string.
pretty_context [] "".
pretty_context [T|Rest] OutStr :- term_to_latex {fst T} TString1, term_to_latex {snd T} TString2, pretty_context Rest RestStr, OutStr = TString1 ^ ":" ^ TString2 ^ "," ^ RestStr.
pred pretty_axrels i:list prop, o:string.
pretty_axrels [] "".
pretty_axrels [axiom A B | Rest] OutString :-
  pretty_psort A AName, pretty_psort B BName, pretty_axrels Rest PRest, OutString = "axiom (" ^ AName ^ "," ^ BName ^ ") " ^ PRest.
pretty_axrels [rel A B C | Rest] OutString :-
  pretty_psort A AName, pretty_psort B BName, pretty_psort C CName, pretty_axrels Rest PRest, OutString = "rel (" ^ AName ^ "," ^ BName ^ "," ^ CName ^ ") " ^ PRest.

%% The example-printing loop. Takes axioms, decide-depth bound, context, goal, prints
%% all possible solutions as a LaTeX itemize list

type exampleAll list prop -> list prop -> int -> list (pair term term) -> term -> prop.
:if "DEBUG:exall" exampleAll AxRels _PP_Hints Int Ctx Goal :-
!, print "Attempting" Goal "\n", std.map Ctx build_clause StoreCtx,
  StoreCtx => AxRels => loop (sigma Term\ asyncr (dd Int) Term (unk Goal), print "Found" Term "\n").

exampleAll AxRels PP_Hints Int Ctx Goal :-
  std.map Ctx build_clause StoreCtx,
  StoreCtx => AxRels => PP_Hints =>
  (
  pretty_axrels AxRels AxRelStrings, pretty_context Ctx CtxStr, term_to_latex Goal GoalStr,
  Intro is "In the system given by $" ^ AxRelStrings ^ "$ print all terms of type $" ^ GoalStr ^ "$ with context ${" ^ CtxStr ^ "}$ and decide-depth " ^ (int_to_string Int),
  print Intro,
  print "\\begin{itemize}",
  loop
   (
     sigma Term\
       asyncr (dd Int) Term (unk Goal),
       term_to_latex Term String,
       OutStr is String,
       print "\\item $" OutStr "$"
   )),
  print "\\end{itemize}".

:if "DEBUG:main" main :- !,
pi prop\ pi ty\ pi a\
axiom (n prop) (n ty) => rel (n prop) (n prop) (n prop) =>
store dd_index a (sort (n prop)) =>
sigma Term\
loop (asyncr (dd 3) (app a #) (unk (sort (n prop))), print "done"),
print Term.
  % pi prop\ pi ty\ pi a\
  %   axiom (n prop) (p ty) => store dd_index a (sort (n prop)) => term_to_latex a "a" =>
  %   rel (n prop) (n prop) (n prop) =>
  %   sort_name prop "Prop" => sort_name ty "Type" => % sigma Term\ sigma Cont\ sigma Boh\
  %   asyncr (dd 3) (app a #) (unk (sort (n prop))).
:if "DEBUG:exall" main :- loop (example X_).
main :- 
print "\\documentclass{scrartcl}
\\usepackage{proofsystem_macros}
\\title{Some examples terms}
\\begin{document}",
loop (example X_),
print "\\end{document}".

%% The examples are below
type example string -> prop.
example "AllNeg" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (n prop) (n ty), rel (n prop) (n prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (n prop))] (sort (n prop)).
example "AllNegPosTy" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (n prop) (p ty), rel (n prop) (n prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      5 [pr a (sort (n prop))] (sort (n prop)).
example "PosTyPosANegGoal" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (p prop) (p ty), axiom (n prop) (p ty), rel (p prop) (p prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (p prop))] (sort (n prop)).
example "PosTyPosAPosGoal" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (p prop) (p ty), axiom (n prop) (p ty), rel (p prop) (p prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (p prop))] (sort (p prop)).
example "IdentityAllNeg" :-
pi prop\ pi ty\ pi a\ exampleAll [axiom (n prop) (n ty), rel (n prop) (n prop) (n prop)] [term_to_latex a "a", sort_name prop "Prop", sort_name ty "Type"] 
      3 [pr a (sort (n prop))] (prod (negbox (app a #)) (x\ negbox (app a #))).
% example "IdentityPosPropNegType" :-
%   print "Fourth example: given a context containing only a positive prop $a$,
%   build all possible terms typable with the identity, where the formula
%   well-formedness is checked with negative bias, with decide-depth 3.\n",
%   pi prop\ pi ty\       % Sort Prop and Sort Type
%     axiom prop ty =>    % Prop is a Type
%     rel prop prop prop =>   % Only non-dependent product between prop
%     pi a\ term_to_latex a "a" => sort_name prop "Prop" => sort_name ty "Type" => 
%       exampleLoop 3 [pr a (sort (n prop))] (prod (app a #) (x\ app a #)).
% example "IdentityPosPropPosType" :-
%   print "Fifth example: given a context containing only a positive prop $a$,
%   build all possible terms typable with the identity, where the formula
%   well-formedness is checked with positive bias, with decide-depth 3.\n",
%   pi prop\ pi ty\       % Sort Prop and Sort Type
%     axiom prop ty =>    % Prop is a Type
%     rel prop prop prop =>   % Only non-dependent product between prop
%     pi a\ term_to_latex a "a" => sort_name prop "Prop" => sort_name ty "Type" => 
%       exampleLoop 3 [pr a (sort (n prop))] (prod (posbox a) (x\ posbox a)).

% example "NegNaturalsNegType" :-
%   print "Sixth example: given a context containing only a negative prop $a$,
%   build all possible terms typable with Church naturals, where the formula
%   well-formedness is checked with negative bias, with decide-depth 4.\n",
%   pi prop\ pi ty\       % Sort Prop and Sort Type
%     axiom prop ty =>    % Prop is a Type
%     rel prop prop prop =>   % Only non-dependent product between prop
%     pi a\ term_to_latex a "a" => sort_name prop "Prop" => sort_name ty "Type" => 
%       exampleLoop 4 [pr a (sort (n prop))] (prod (app a #) (x\ prod (prod (app a #) (x\ app a #)) (x\ app a #))).
% example "PosNaturalsNegType" :-
%   print "Seventh example: given a context containing only a positive prop $a$,
%   build all possible terms typable with Church naturals, where the formula
%   well-formedness is checked with negative bias, with decide-depth 4.\n",
%   pi prop\ pi ty\       % Sort Prop and Sort Type
%     axiom prop ty =>    % Prop is a Type
%     rel prop prop prop =>   % Only non-dependent product between prop
%     pi a\ term_to_latex a "a" => sort_name prop "Prop" => sort_name ty "Type" => 
%       exampleLoop 4 [pr a (sort (p prop))] (prod (app a #) (x\ prod (prod (app a #) (x\ app a #)) (x\ app a #))).
% example "PosNaturalsNegType" :-
%   print "Eight example: given a context containing only a negative prop $a$,
%   build all possible terms typable with Church naturals, where the formula
%   well-formedness is checked with positive bias, with decide-depth 4.\n",
%   pi prop\ pi ty\       % Sort Prop and Sort Type
%     axiom prop ty =>    % Prop is a Type
%     rel prop prop prop =>   % Only non-dependent product between prop
%     pi a\ term_to_latex a "a" => sort_name prop "Prop" => sort_name ty "Type" => 
%       exampleLoop 4 [pr a (sort (n prop))] (prod (posbox a) (x\ prod (prod (posbox a) (x\ posbox a)) (x\ posbox a))).

% example "NegativeLFTypes" :-
%   print "Ninth example: given an empty context,
%   build all possible negative LF propositions with decide-depth 3.\n",
%   pi prop\ pi ty\       % Sort Prop and Sort Type
%     axiom prop ty =>    % Prop is a Type
%     rel prop prop prop =>   % Non-dependent product between prop
%     rel ty prop prop =>   %  Props depending on terms
%     sort_name prop "Prop" => sort_name ty "Type" => 
%     exampleLoop 3 [] (sort (n prop)).

% example "LFNaturals" :-
%   print "Tenth example: Church naturals in LF; negative atom, traditional type syntax",
%   pi prop\ pi ty\       % Sort Prop and Sort Type
%     axiom prop ty =>    % Prop is a Type
%     rel prop prop prop =>   % Non-dependent product between prop
%     rel ty prop prop =>   %  Props depending on terms
%     sort_name prop "Prop" => sort_name ty "Type" => 
%     exampleLoop 5 [] (prod (sort (n prop)) (a\ (prod (app a #) (x\ prod (prod (app a #) (x\ app a #)) (x\ app a #))))).
% example "LFNaturalsSharedType" :-
%   print "Tenth example: Church naturals in LF; negative atom, shared type syntax",
%   pi prop\ pi ty\       % Sort Prop and Sort Type
%     axiom prop ty =>    % Prop is a Type
%     rel prop prop prop =>   % Non-dependent product between prop
%     rel ty prop prop =>   %  Props depending on terms
%     sort_name prop "Prop" => sort_name ty "Type" => sigma Ty\
%     exampleLoop 5 [] (prod (sort (n prop)) (a\ app (prod (app a #) (x\ app a #)) (kappa Ty (i\ (prod (app a #) (x\ prod i (y\ app a #) )))))).

% % example "NegativeSystemF" :-
% %   print "Sixth example: given a context containing only a negative prop $a$,
% %   build all possible negative System F propositions with decide-depth 2.\n",
% %   pi prop\ pi ty\       % Sort Prop and Sort Type
% %     axiom prop ty =>    % Prop is a Type
% %     rel prop prop prop =>   % Non-dependent product between prop
% %     rel ty prop prop =>   %  Props depending on terms
% %     rel prop ty ty =>   %  Props depending on terms
% %     pi a\ term_to_latex a "a" =>
% %       exampleLoop 2 [pr a (sort (p prop))] (sort (n prop)).

% % example "IdentitySystemF" :-
% %   print "Seventh example: given a context containing only a negative prop $a$,
% %   build all possible System F terms of type $\\ptsapp{a}{\\ptsnil}$ with decide-depth 5.\n",
% %   pi prop\ pi ty\       % Sort Prop and Sort Type
% %     axiom prop ty =>    % Prop is a Type
% %     rel prop prop prop =>   % Non-dependent product between prop
% %     rel ty prop prop =>   %  Props depending on terms
% %     pi a\ term_to_latex a "a" =>
% %       exampleLoop 5 [pr a (sort (n prop))] (prod (app a #) (x\ app a #)). %% Given "a" positive, build all negative propositions 

%% Old example loop code
% type exampleLoop int -> list (pair term term) -> term -> prop.
% :if "DEBUG" exampleLoop Int Ctx Goal :-
% !, print "Attempting" Goal "\n", std.map Ctx build_clause StoreCtx,
  % StoreCtx => loop (sigma Term\ asyncr (dd Int) Term (str Goal), print "Found" Term "\n").

% exampleLoop Int Ctx Goal :-
  % std.map Ctx build_clause StoreCtx,
  % StoreCtx =>
  % (
  % print "\\begin{itemize}",
  % loop
  %  (
    %  sigma Term\
      %  asyncr (dd Int) Term (unk Goal),
      %  term_to_latex Term String,
      %  OutStr is String,
      %  print "\\item $" OutStr "$"
  %  )),
  % print "\\end{itemize}".
