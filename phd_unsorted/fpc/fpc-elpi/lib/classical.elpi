% Signature for first-order classical logic formulas.

sig classical.
accum_sig lib.

kind i                          type.
kind bool                       type.

type tt, ff                     bool.
type ng                     	bool -> bool.
type and, or, imp, equiv    	bool -> bool -> bool.
type forall, exists             (i -> bool) -> bool.

type pred_pname    bool -> string -> list i -> o.
type fun_pname     i    -> string -> list i -> o.

type atomic        bool -> o.

type copyi         i -> i -> o.
type copybool      bool -> bool -> o.


% First-order terms
type a        i.
type b        i.
type c        i.
type d        i.
type e        i.
type n1, n2, n3, n4, n5  i.

type f        i -> i.
type f        i -> i.
type h        i -> i -> i.
type g        i -> i -> i.

% Predicates in the "client space"
type m        bool.
type mm       bool.
type q        bool.
type qq       bool.
type s        i -> bool.
type r        i -> i -> bool.

module classical.

% By specifying print names (pname) for all signature items, we can
% get copy clauses for free.

copyi    T S :- fun_pname T Name L,  fun_pname S Name K,  mappred copyi L K.
copybool T S :- pred_pname T Name L, pred_pname S Name K, mappred copyi L K.

atomic A :- pred_pname A _ _.

pred_pname m       "m" [].
pred_pname mm      "mm" [].
pred_pname q       "q" [].
pred_pname (s X)   "s" [X].
pred_pname (r X Y) "r" [X,Y].

fun_pname  a      "a" [].
fun_pname  b      "b" [].
fun_pname  c      "d" [].
fun_pname  d      "d" [].
fun_pname  e      "e" [].

fun_pname (f X)   "f" [X].

fun_pname (h X Y) "h" [X, Y].
fun_pname (g X Y) "g" [X, Y].
