kind form, i type.
type n, p           A -> form.
type d-, d+      form -> form. 
type &-&, &+&    form -> form -> form. 
type !+!         form -> form -> form.
type arr         form -> form -> form.
type all, some   (i -> form)  -> form.
type f, t+, t-                   form.
infixr &-&, &+&  6.
infixr !+!  5.
infixr arr 4. 

kind cert, index                         type.
kind choice                              type.
type left, right                       choice.

type storeL_jc                     cert -> cert -> index -> prop.
type decideL_je                    cert -> cert -> index -> prop.
type decideR_je, storeR_jc,
     releaseL_je, releaseR_je      cert -> cert -> prop.
type initialL_je                   cert -> prop.
type initialR_je                   cert -> index -> prop.
type cut_je                        cert -> cert -> cert -> form -> prop.
type some_jc, all_jc               cert -> (i -> cert) -> prop.
type some_je, all_je               cert -> cert -> i -> prop.
type arr_jc, andPos_jc             cert -> cert -> prop.
type or_jc, andNeg_jc,
     arr_je, andPos_je             cert ->  cert -> cert -> prop.
type or_je, andNeg_je              cert -> cert -> choice -> prop.
type true_je                       cert -> prop.
type true_jc                       cert -> cert -> prop.
type ljf_entry      cert -> form -> prop.
kind rhs                                 type.
type str, unk                     form -> rhs.
kind seq                                 type.
type async           list form -> rhs  -> seq.
type lfoc                 form -> form -> seq.
type rfoc                         form -> seq.
type storage               index -> form -> prop.
type check                  cert -> seq  -> prop.

type isNegForm, isNegAtm, isPosForm, isPosAtm, isNeg, isPos     form -> prop. 

isNegAtm (n _).
isPosAtm (p _).

isNegForm (_ &-& _) & isNegForm (_ arr _).
isNegForm (all _)   & isNegForm (d- _)    & isNegForm t-.
isNeg A :- isNegForm A ; isNegAtm A.

isPosForm (_ !+! _) & isPosForm (_ &+& _).
isPosForm (d+ _)    & isPosForm (some _)  & isPosForm f  &  isPosForm t+.
isPos A :- isPosForm A ; isPosAtm A.

%check A B :- announce (check A B).

ljf_entry Cert Form :- check Cert (async [] (unk Form)).

% Structural Rules
% decide
check Cert (async [] (str R)) :- decideL_je Cert Cert' Indx,
  storage Indx N, isNeg N, check Cert' (lfoc N R).
check Cert (async [] (str P)) :-
  isPos P, decideR_je Cert Cert', check Cert' (rfoc P).
% release
check Cert (lfoc P R) :- isPos P, releaseL_je Cert Cert', check Cert' (async [P] (str R)).
check Cert (rfoc N)   :- isNeg N, releaseR_je Cert Cert', check Cert' (async [] (unk N)).
% store
check Cert (async [C|Theta] R) :- (isNeg C ; isPosAtm C),
  storeL_jc Cert Cert' Indx, 
  storage Indx C => check Cert' (async Theta R).
check Cert (async [] (unk D)) :- (isPos D ; isNegAtm D),
  storeR_jc Cert Cert', check Cert' (async [] (str D)).

% Identity rules
% initial
check Cert (lfoc Na Na) :- isNegAtm Na, initialL_je Cert.
check Cert (rfoc Pa)    :- isPosAtm Pa, initialR_je Cert Indx, storage Indx Pa.
% cut
check Cert (async [] (str R)) :- cut_je Cert CertA CertB F, 
  check CertA (async [] (unk F)), check CertB (async [F] (str R)).

% Asynchronous Rules
% arrow
check Cert (async [] (unk (A arr B))) :-
  arr_jc Cert Cert', check Cert' (async [A] (unk B)).
% disjunction
check Cert (async [(A !+! B)| Theta] R) :- or_jc Cert CertA CertB,
  check CertA (async [A | Theta] R), check CertB (async [B | Theta] R).
% conjunction
check Cert  (async [(A &+& B )| Theta] R) :- andPos_jc Cert Cert',
  check Cert' (async [A , B | Theta] R).
check Cert (async [] (unk (A &-& B))) :- andNeg_jc Cert CertA CertB,
  check CertA (async [] (unk A)), check CertB (async [] (unk B)).
% quantifers
check Cert (async [some B | Theta] R) :- some_jc Cert Cert',
  pi w\ check (Cert' w) (async [B w | Theta] R).
check Cert (async [] (unk (all B))) :- all_jc Cert Cert',
  pi w\ check (Cert' w) (async [] (unk (B w))).
% Units
check _Cert (async [] (unk t-)).
check _Cert (async [f | _] _).
check Cert (async [t+| Theta] R) :- true_jc Cert Cert', check Cert' (async Theta R).
% Delays
check Cert (async [d+ A|Theta] R)   :- check Cert (async [A|Theta] R).
check Cert (async [] (unk (d- R))) :- check Cert (async [] (unk R)).

% Synchronous Rules
% arrow
check Cert (lfoc (A arr B) R) :- arr_je Cert CertA CertB,
  check CertA (rfoc A), check CertB (lfoc B R).
% disjunction
check Cert (rfoc (A !+! B)) :- or_je Cert Cert' Choice, 
  ((Choice = left,  check Cert' (rfoc A)); (Choice = right, check Cert' (rfoc B))).
% conjunction
check Cert (rfoc (A &+& B)) :- andPos_je Cert CertA CertB,
   check CertA (rfoc A), check CertB (rfoc B).
check Cert (lfoc (A &-& B) R) :- andNeg_je Cert Cert' Choice,
   ((Choice = left,  check Cert' (lfoc A R));
    (Choice = right, check Cert' (lfoc B R))).
% quantifers
check Cert (rfoc (some B)) :- some_je Cert Cert' T, check Cert' (rfoc (B T)).
check Cert (lfoc (all B) R) :- all_je Cert Cert' T, check Cert' (lfoc (B T) R).
% Units
check Cert (rfoc t+) :- true_je Cert.
% Delays
check Cert (rfoc (d+ A))            :- check Cert (rfoc A). 
check Cert (lfoc (d- A) R)          :- check Cert (lfoc A R) .

/* start */
kind deb            type.
type apply          int -> list deb -> deb.
type lc             int ->      deb -> cert.
type args           int -> list deb -> cert.    
type idx                       int -> index.
arr_jc      (lc C D) (lc C D).
storeR_jc   (lc C D) (lc C D).
releaseR_je (lc C D) (lc C D).
storeL_jc   (lc C D) (lc C' D) (idx C) :- C' is C + 1.
decideL_je  (lc C (apply H A)) (args C A) (idx V) :- V is C - H - 1.
initialL_je (args _ []).
arr_je      (args C (A::As)) (lc C A) (args C As).
/* end */

/* pairing */
% type   idx2   idx -> idx -> idx.
type   pair#   cert -> cert -> cert.
true_jc (pair# L0 R0) (pair# L1 R1) :-
	true_jc L0 L1,
	true_jc R0 R1.

andPos_jc (pair# L0 R0) (pair# L1 R1) :-
	andPos_jc L0 L1,
	andPos_jc R0 R1.

or_jc (pair# L0 R0) (pair# L1 R1) (pair# L2 R2) :-
	or_jc L0 L1 L2,
	or_jc R0 R1 R2.

arr_jc (pair# L0 R0) (pair# L1 R1) :-
	arr_jc L0 L1,
	arr_jc R0 R1.

true_je (pair# L0 R0) :-
	true_je L0,
	true_je R0.

andPos_je (pair# L0 R0) (pair# L1 R1) (pair# L2 R2) :-
	andPos_je L0 L1 L2,
	andPos_je R0 R1 R2.

or_je (pair# L0 R0) (pair# L1 R1) C :-
	or_je L0 L1 C,
	or_je R0 R1 C.

arr_je (pair# L0 R0) (pair# L1 R1) (pair# L2 R2) :-
	arr_je L0 L1 L2,
	arr_je R0 R1 R2.

all_jc (pair# L0 R0) (x\ pair# (L1 x) (R1 x)) :-
	all_jc L0 L1,
	all_jc R0 R1.

some_jc (pair# L0 R0) (x\ pair# (L1 x) (R1 x)) :-
	some_jc L0 L1,
	some_jc R0 R1.

all_je (pair# L0 R0) (pair# L1 R1) T :-
	all_je L0 L1 T,
	all_je R0 R1 T.

some_je (pair# L0 R0) (pair# L1 R1) T :-
	some_je L0 L1 T,
	some_je R0 R1 T.
% Decide depth
type indx index.
type dd n -> cert.
type z n.
type s n -> n.
andNeg_jc      (dd D) (dd D) (dd D).
or_jc       (dd D) (dd D) (dd D).
all_jc         (dd D) (x\ dd D).
storeL_jc      (dd D) (dd D) indx.
storeR_jc      (dd D) (dd D).
or_je       (dd D) (dd D) _Choice.
andPos_je      (dd D) (dd D) (dd D).
some_je        (dd D) (dd D) _T.
releaseR_je     (dd D) (dd D).
releaseL_je     (dd D) (dd D).
initialL_je     (dd _).
initialR_je     (dd _) indx.
true_je        (dd _).
decideL_je      (dd (s D)) (dd D) indx.
decideR_je     (dd D) (dd D). 